---
title: "CAR-code"
format: html
editor: source
---


```{r}
rm(list=ls())
library(data.table)
```
```{r}
# ============================================
# Build: cik, cusip, gvkey, permco, ticker
# (Optionally quarter-level)
# ============================================

# Packages
library(DBI)
library(RPostgres)
library(data.table)
library(zoo)  # for as.yearqtr

# ----------------------------
# 0) User inputs
# ----------------------------
wrds_user   <- Sys.getenv("WRDS_USER")  # set this in your env
date_start  <- as.Date("2000-01-01")
date_end    <- as.Date("2025-12-31")
make_quarter_panel <- TRUE  # set FALSE if you want a flat crosswalk without quarters

# ----------------------------
# 1) Connect to WRDS
# ----------------------------
con <- dbConnect(
  Postgres(),
  host   = "wrds-pgdata.wharton.upenn.edu",
  port   = 9737,
  dbname = "wrds",
  sslmode= "require",
  user   = wrds_user
)
on.exit(try(dbDisconnect(con), silent = TRUE))

# ----------------------------
# 2) Minimal SQL pulls
# ----------------------------

# (A) CRSP monthly: permno/permco/date (we'll attach ticker/cusip from stocknames by interval)
sql_msf <- sprintf("
  SELECT permno, permco, date::date AS date
  FROM crsp.msf
  WHERE date BETWEEN DATE '%s' AND DATE '%s'
  ORDER BY permno, date;
", format(date_start, "%Y-%m-%d"), format(date_end, "%Y-%m-%d"))

# (B) CRSP stocknames: ticker + (n)cusip + name validity windows
sql_stocknames <- "
  SELECT
    permno,
    ticker,
    cusip,
    ncusip,
    namedt::date   AS namedt,
    nameendt::date AS nameendt
  FROM crsp.stocknames;
"

# (C) CRSP–Compustat linktable with link dates
sql_ccm <- "
  SELECT
    gvkey,
    lpermno AS permno,
    lpermco AS permco,
    linkdt::date     AS linkdt,
    linkenddt::date  AS linkenddt
  FROM crsp.ccmxpf_linktable
  WHERE linktype IN ('LU','LC')
    AND linkprim IN ('C','P')
    AND usedflag = 1;
"

# (D) Compustat company: CIK
sql_comp_company <- "
  SELECT
    gvkey,
    cik
  FROM comp.company;
"

msf   <- as.data.table(dbGetQuery(con, sql_msf))
names <- as.data.table(dbGetQuery(con, sql_stocknames))
ccm   <- as.data.table(dbGetQuery(con, sql_ccm))
comp  <- as.data.table(dbGetQuery(con, sql_comp_company))

# ----------------------------
# 3) Clean types + prepare intervals
# ----------------------------
msf[, date := as.Date(date)]

names[, `:=`(
  namedt   = as.Date(namedt),
  nameendt = as.Date(nameendt)
)]
# Open-ended name intervals -> far future
far_future <- as.Date("2099-12-31")
names[is.na(nameendt), nameendt := far_future]

ccm[, `:=`(
  linkdt    = as.Date(linkdt),
  linkenddt = as.Date(linkenddt)
)]
# Open-ended links -> far future
ccm[is.na(linkenddt), linkenddt := far_future]

# ----------------------------
# 4) Attach ticker/CUSIP by CRSP name validity (interval join)
#    msf dates must fall within [namedt, nameendt] for the same permno
# ----------------------------
# Prepare msf as point-interval for foverlaps
msf_int <- copy(msf)[, `:=`(date_start = date, date_end = date)]
setkey(msf_int, permno, date_start, date_end)

names_int <- copy(names)[, `:=`(name_start = namedt, name_end = nameendt)]
setkey(names_int, permno, name_start, name_end)

msf_named <- foverlaps(
  x = msf_int,
  y = names_int,
  by.x = c("permno", "date_start", "date_end"),
  by.y = c("permno", "name_start", "name_end"),
  type = "within",
  nomatch = 0L
)

# Keep the essentials; prefer ncusip when available
msf_named[, cusip_final := fifelse(!is.na(ncusip) & ncusip != "", ncusip, cusip)]
msf_named <- msf_named[, .(permno, permco = i.permco, date = date_start,
                           ticker, cusip = cusip_final)]

# ----------------------------
# 5) Attach gvkey by link validity (interval join on permno & date ∈ [linkdt, linkenddt])
# ----------------------------
ccm_int <- copy(ccm)[, `:=`(link_start = linkdt, link_end = linkenddt)]
setkey(ccm_int, permno, link_start, link_end)

msf_named_int <- copy(msf_named)[, `:=`(date_start = date, date_end = date)]
setkey(msf_named_int, permno, date_start, date_end)

joined <- foverlaps(
  x = msf_named_int,
  y = ccm_int,
  by.x = c("permno", "date_start", "date_end"),
  by.y = c("permno", "link_start", "link_end"),
  type = "within",
  nomatch = 0L
)

# Choose CRSP permco (from msf) as canonical; keep gvkey from linktable
joined <- joined[, .(
  date = date_start,
  permno,
  permco = i.permco,     # permco from msf (i.* are columns from x in foverlaps)
  gvkey,
  ticker = i.ticker,
  cusip  = i.cusip
)]

# ----------------------------
# 6) Add CIK from Compustat
# ----------------------------
final_dt <- merge(joined, comp, by = "gvkey", all.x = TRUE)

# Deduplicate per date if multiple rows (rare; keep last deterministically)
setorder(final_dt, permno, date, ticker, cusip)
final_dt <- unique(final_dt, by = c("gvkey", "permco", "permno", "date"))

# ----------------------------
# 7) Optional: quarter-level panel
# ----------------------------
if (make_quarter_panel) {
  final_dt[, quarter := as.yearqtr(date)]
  # keep one row per (gvkey, permco, permno, quarter); choose the last within-quarter
  panel_quarter <- final_dt[
    order(permno, quarter, date),
    .SD[.N],
    by = .(gvkey, permco, permno, quarter)
  ][, .(quarter, cik, cusip, gvkey, permco, ticker, permno)]

  # Show sample
  print(head(panel_quarter, 10))
} else {
  # Flat daily/monthly mapping
  panel_flat <- final_dt[, .(date, cik, cusip, gvkey, permco, ticker, permno)]
  print(head(panel_flat, 10))
}

# ----------------------------
# 8) Convenience: "current" crosswalk as of a reference date (optional)
# ----------------------------
as_of <- as.Date("2025-06-30")
current_xwalk <- final_dt[date <= as_of][
  order(permno, date),
  .SD[.N],
  by = .(gvkey, permco, permno)
][, .(as_of, cik, cusip, gvkey, permco, ticker, permno)]

# Display a peek
print(head(current_xwalk, 10))

```


```{r}
# #========================
# # 3) (Only) WRDS SQL pulls
# #========================
# # --- CRSP daily stock returns (dsf): RET as decimal; use permco,permno,date,ret
# sql_dsf <- sprintf("
#   SELECT permco, permno, date::date AS date, ret::float8 AS ret
#   FROM crsp.dsf
#   WHERE permco IN (%s)
#     AND date BETWEEN DATE '%s' AND DATE '%s'
#   ORDER BY permco, date
# ", permco_csv, format(start_date, "%Y-%m-%d"), format(end_date, "%Y-%m-%d"))
# 
# # --- CRSP value-weighted market return (dsi): VWRETD as decimal
# sql_dsi <- sprintf("
#   SELECT date::date AS date, vwretd::float8 AS vwretd
#   FROM crsp.dsi
#   WHERE date BETWEEN DATE '%s' AND DATE '%s'
#   ORDER BY date
# ", format(start_date, "%Y-%m-%d"), format(end_date, "%Y-%m-%d"))


SELECT permco, permno, ticker, date
FROM crsp.msf
WHERE date BETWEEN DATE '2000-01-01' AND DATE '2025-12-31'
ORDER BY permno, date;

SELECT gvkey,
       lpermco AS permco,
       lpermno AS permno,
       linkdt,
       linkenddt
FROM crsp.ccmxpf_linktable
WHERE linktype IN ('LU','LC')
  AND linkprim IN ('C','P')
  AND usedflag = 1;
  
library(data.table)
library(zoo)          # for as.yearqtr
  

# --- Clean types
crsp[, date := as.Date(date)]
link[, linkdt := as.Date(linkdt)]
link[, linkenddt := as.Date(linkenddt)]

# Open-ended links: set linkenddt to a far future date for interval-join convenience
far_future <- as.Date("2099-12-31")
link[is.na(linkenddt), linkenddt := far_future]

# --- Build an interval join: match crsp row if date in [linkdt, linkenddt]
# Prepare data for foverlaps(): need start/end columns
crsp_int <- copy(crsp)[, `:=`(date_start = date, date_end = date)]
setkey(crsp_int, permno, date_start, date_end)

link_int <- copy(link)[, `:=`(link_start = linkdt, link_end = linkenddt)]
setkey(link_int, permno, link_start, link_end)

# Interval join on permno & date within [linkdt, linkenddt]
joined <- foverlaps(
  x = crsp_int,
  y = link_int,
  by.x = c("permno", "date_start", "date_end"),
  by.y = c("permno", "link_start", "link_end"),
  type = "within",
  nomatch = 0L
)

# Keep relevant columns and make a quarter label
joined[, quarter := as.yearqtr(date)]
out <- joined[, .(quarter, ticker, gvkey, permco = i.permco, permno)]

# If multiple tickers map within a quarter (due to changes), pick one rule:
# e.g., the last observation in that quarter for stability
out_quarterly <- out[
  order(permno, quarter, ticker),
  .SD[.N], by = .(gvkey, permco, permno, quarter)
]

```

```{r}
# =========================
# 1) Synthetic data generator
# =========================
set.seed(123)

# Trading calendar (weekdays only)
start_date <- as.Date("2022-01-01")
end_date   <- as.Date("2022-12-31")
cal        <- data.table(date = seq(start_date, end_date, by = "day"))
cal        <- cal[weekdays(date) %chin% c("Monday","Tuesday","Wednesday","Thursday","Friday")]

# Market process (daily)
N <- nrow(cal)
mu_mkt  <- 0.0003                          # market daily drift
sig_mkt <- 0.01                            # market daily volatility
cal[, vwretd := rnorm(.N, mu_mkt, sig_mkt)]

# Firms
n_firms <- 50L
permcos <- seq(10001L, 10000L + n_firms)
firm_params <- data.table(
  permco = permcos,
  alpha  = rnorm(n_firms, 0.00005, 0.0003),
  beta   = pmax(0.2, rnorm(n_firms, 1.0, 0.3)),
  sigma  = runif(n_firms, 0.008, 0.02)
)

# Expand to panel and simulate returns
dt <- CJ(permco = permcos, date = cal$date)
dt <- firm_params[dt, on = "permco"]
dt <- cal[dt, on = "date"] # adds vwretd
dt[, ret := alpha + beta*vwretd + rnorm(.N, 0, sigma)]
setorder(dt, permco, date)
```

```{r}
# =========================
# 2) Synthetic event list
# =========================
# One event per firm; avoid edges to ensure room for estimation and event windows
buffer_days <- 80L
eligible_dates <- cal$date[buffer_days:(nrow(cal) - buffer_days)]
events <- data.table(
  permco     = sample(permcos, n_firms, replace = FALSE),
  event_date = sample(eligible_dates, n_firms, replace = FALSE)
)

# Optional: add a small abnormal “shock” on event day to make CAR visible
shock <- 0.01  # +1% on t=0
dt[events, on = .(permco, date = event_date), ret := ret + shock]

# =========================
# 3) Event-time indexing (trading-day t with t=0 on event date)
# =========================
dt[, trd_idx := seq_len(.N), by = permco]
ev_idx <- dt[events, on = .(permco, date = event_date),
             .(permco, event_date, ev_trd_idx = trd_idx)]
dt_ev  <- dt[ev_idx, on = .(permco)]
dt_ev[, t := trd_idx - ev_trd_idx]
```


```{r}
# =========================
# 4) AR/CAR computation
#    Choose: "market_adj" or "market_model"
# =========================
ar_model <- "market_model"     # change to "market_adj" if desired
L_est    <- 120L               # estimation window length (trading days)
gap_est  <- 20L                # blackout gap
L_event  <- 2L                 # days before event
R_event  <- 2L                 # days after event

# Label windows (trading-day indices)
dt_ev[, wtype :=
        fifelse(t >= -L_event & t <= R_event, "event",
        fifelse(t <= -(gap_est + 1L) & t >= -(gap_est + L_est), "est", NA_character_))
     ]

# Keep only needed rows
dt_ev <- dt_ev[!is.na(wtype)]

# Compute ARs
if (ar_model == "market_adj") {
  ar <- dt_ev[wtype == "event",
              .(permco, event_date, date, t, ret, vwretd,
                AR = ret - vwretd)]
} else {
  # Market model: ret = alpha + beta*vwretd + eps (estimated on "est" window)
  ar <- dt_ev[, {
    est <- .SD[wtype == "est"]
    ev  <- .SD[wtype == "event"]
    if (nrow(ev) == 0L) return(NULL)
    if (nrow(est) >= 50L) {
      fit <- lm(ret ~ vwretd, data = est)
      er  <- coef(fit)[1] + coef(fit)[2]*ev$vwretd
      ev[, AR := ret - as.numeric(er)]
    } else {
      ev[, AR := ret - vwretd]  # fallback to market-adjusted
    }
    ev[, .(permco, event_date, date, t, ret, vwretd, AR)]
  }, by = .(permco, event_date)]
}

# CAR within the event window per event
setorder(ar, permco, event_date, t)
ar[, CAR := cumsum(AR), by = .(permco, event_date)]
```


```{r}
# =========================
# 5) Aggregates for reporting (CAAR/CACAR)
# =========================
# Cross-sectional average AR by event time
caar <- ar[, .(AAR = mean(AR), CAR_bar = mean(CAR)), by = t]

# Event-level CAR over the full window [−L_event, +R_event]
car_event <- ar[t == R_event, .(permco, event_date, CAR_window = CAR)]

# Simple t-stats (no clustering; for illustration only)
caar[, `:=`(
  n_events = uniqueN(ar[, .(permco, event_date)]),
  t_AAR    = AAR / (sd(ar$AR) / sqrt(uniqueN(ar[, .(permco, event_date)])))
)]

# Outputs
head(ar)         # AR and CAR at each t
head(caar)       # average AR/CAR by t
head(car_event)  # end-of-window CAR per event
```

